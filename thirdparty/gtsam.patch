diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5bad53988..c692f2aa2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,5 +1,8 @@
 cmake_minimum_required(VERSION 3.0)
 
+set(CMAKE_CXX_STANDARD 20)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+
 # new feature to Cmake Version > 2.8.12
 # Mac ONLY. Define Relative Path on Mac OS
 if(NOT DEFINED CMAKE_MACOSX_RPATH)
diff --git a/cmake/HandleBoost.cmake b/cmake/HandleBoost.cmake
index 6c742cfe5..7268a8bf1 100644
--- a/cmake/HandleBoost.cmake
+++ b/cmake/HandleBoost.cmake
@@ -23,13 +23,18 @@ endif()
 
 # Store these in variables so they are automatically replicated in GTSAMConfig.cmake and such.
 set(BOOST_FIND_MINIMUM_VERSION 1.65)
-set(BOOST_FIND_MINIMUM_COMPONENTS serialization system filesystem thread program_options date_time timer chrono regex)
+set(BOOST_FIND_MINIMUM_COMPONENTS serialization filesystem thread program_options date_time timer chrono regex)
 
 find_package(Boost ${BOOST_FIND_MINIMUM_VERSION} COMPONENTS ${BOOST_FIND_MINIMUM_COMPONENTS})
 
 # Required components
-if(NOT Boost_SERIALIZATION_LIBRARY OR NOT Boost_SYSTEM_LIBRARY OR NOT Boost_FILESYSTEM_LIBRARY OR
+if(NOT Boost_SERIALIZATION_LIBRARY OR NOT Boost_FILESYSTEM_LIBRARY OR
     NOT Boost_THREAD_LIBRARY OR NOT Boost_DATE_TIME_LIBRARY)
+  message("WARNING: Missing required boost components")
+  message("Boost_SERIALIZATION_LIBRARY: ${Boost_SERIALIZATION_LIBRARY}")
+  message("Boost_FILESYSTEM_LIBRARY: ${Boost_FILESYSTEM_LIBRARY}")
+  message("Boost_THREAD_LIBRARY: ${Boost_THREAD_LIBRARY}")
+  message("Boost_DATE_TIME_LIBRARY: ${Boost_DATE_TIME_LIBRARY}")
   message(FATAL_ERROR "Missing required Boost components >= v1.65, please install/upgrade Boost or configure your search paths.")
 endif()
 
@@ -37,7 +42,6 @@ option(GTSAM_DISABLE_NEW_TIMERS "Disables using Boost.chrono for timing" OFF)
 # Allow for not using the timer libraries on boost < 1.48 (GTSAM timing code falls back to old timer library)
 set(GTSAM_BOOST_LIBRARIES
   Boost::serialization
-  Boost::system
   Boost::filesystem
   Boost::thread
   Boost::date_time
diff --git a/cmake/HandleEigen.cmake b/cmake/HandleEigen.cmake
index b3b4f66b6..3342101f1 100644
--- a/cmake/HandleEigen.cmake
+++ b/cmake/HandleEigen.cmake
@@ -18,6 +18,27 @@ if(GTSAM_USE_SYSTEM_EIGEN)
     # versions.  So here I use the target itself to get the proper include
     # directory (it is generated by cmake, thus has the correct path)
     get_target_property(GTSAM_EIGEN_INCLUDE_FOR_BUILD Eigen3::Eigen INTERFACE_INCLUDE_DIRECTORIES)
+    
+    # Handle case where INTERFACE_INCLUDE_DIRECTORIES returns a list
+    # Get the first directory if it's a list
+    if(GTSAM_EIGEN_INCLUDE_FOR_BUILD)
+        # Check if it's a list by trying to get the length
+        list(LENGTH GTSAM_EIGEN_INCLUDE_FOR_BUILD LIST_LEN)
+        if(LIST_LEN GREATER 1)
+            # It's a list, get the first element
+            list(GET GTSAM_EIGEN_INCLUDE_FOR_BUILD 0 GTSAM_EIGEN_INCLUDE_FOR_BUILD)
+        endif()
+    endif()
+    
+    # Also try to get EIGEN3_INCLUDE_DIR if available (some Eigen installations set this)
+    if(NOT GTSAM_EIGEN_INCLUDE_FOR_BUILD AND DEFINED EIGEN3_INCLUDE_DIR)
+        set(GTSAM_EIGEN_INCLUDE_FOR_BUILD "${EIGEN3_INCLUDE_DIR}")
+    endif()
+    
+    # Print the Eigen include path being used
+    if(GTSAM_EIGEN_INCLUDE_FOR_BUILD)
+        message(STATUS "Using Eigen include directory: ${GTSAM_EIGEN_INCLUDE_FOR_BUILD}")
+    endif()
 
     # check if MKL is also enabled - can have one or the other, but not both!
     # Note: Eigen >= v3.2.5 includes our patches
@@ -59,27 +80,142 @@ else()
 endif()
 
 # Detect Eigen version:
-set(EIGEN_VER_H "${GTSAM_EIGEN_INCLUDE_FOR_BUILD}/Eigen/src/Core/util/Macros.h")
-if (EXISTS ${EIGEN_VER_H})
-    file(READ "${EIGEN_VER_H}" STR_EIGEN_VERSION)
+set(GTSAM_EIGEN_VERSION "")
+if(GTSAM_USE_SYSTEM_EIGEN)
+    # First try to use EIGEN3_VERSION if it's available from Eigen3Config.cmake
+    # Also check Eigen3_VERSION (set by find_package) and PACKAGE_VERSION (from Eigen3ConfigVersion.cmake)
+    if(DEFINED EIGEN3_VERSION AND NOT EIGEN3_VERSION STREQUAL "")
+        set(GTSAM_EIGEN_VERSION "${EIGEN3_VERSION}")
+    elseif(DEFINED Eigen3_VERSION AND NOT Eigen3_VERSION STREQUAL "")
+        set(GTSAM_EIGEN_VERSION "${Eigen3_VERSION}")
+    else()
+        # Try to read PACKAGE_VERSION from Eigen3ConfigVersion.cmake
+        # Eigen3_DIR should be set by find_package(Eigen3 CONFIG)
+        if(DEFINED Eigen3_DIR)
+            set(EIGEN3_CONFIG_VERSION_CMAKE "${Eigen3_DIR}/Eigen3ConfigVersion.cmake")
+            if(EXISTS "${EIGEN3_CONFIG_VERSION_CMAKE}")
+                # Read the version from the file
+                file(READ "${EIGEN3_CONFIG_VERSION_CMAKE}" EIGEN3_VERSION_FILE)
+                string(REGEX MATCH "set\\(PACKAGE_VERSION \"([0-9]+\\.[0-9]+\\.[0-9]+)\"\\)" _ "${EIGEN3_VERSION_FILE}")
+                if(CMAKE_MATCH_1)
+                    set(GTSAM_EIGEN_VERSION "${CMAKE_MATCH_1}")
+                endif()
+            endif()
+        endif()
+        # If still not found, try to find Eigen3ConfigVersion.cmake
+        if(NOT GTSAM_EIGEN_VERSION)
+            find_file(EIGEN3_CONFIG_VERSION_CMAKE
+                NAMES Eigen3ConfigVersion.cmake
+                PATHS
+                    ${Eigen3_DIR}
+                    /opt/homebrew/share/eigen3/cmake
+                    /usr/local/share/eigen3/cmake
+                    /usr/share/eigen3/cmake
+                NO_DEFAULT_PATH
+            )
+            if(NOT EIGEN3_CONFIG_VERSION_CMAKE)
+                find_file(EIGEN3_CONFIG_VERSION_CMAKE Eigen3ConfigVersion.cmake PATH_SUFFIXES eigen3/cmake cmake/eigen3)
+            endif()
+            if(EIGEN3_CONFIG_VERSION_CMAKE)
+                # Read the version from the file
+                file(READ "${EIGEN3_CONFIG_VERSION_CMAKE}" EIGEN3_VERSION_FILE)
+                string(REGEX MATCH "set\\(PACKAGE_VERSION \"([0-9]+\\.[0-9]+\\.[0-9]+)\"\\)" _ "${EIGEN3_VERSION_FILE}")
+                if(CMAKE_MATCH_1)
+                    set(GTSAM_EIGEN_VERSION "${CMAKE_MATCH_1}")
+                endif()
+            endif()
+        endif()
+    endif()
+    
+    # If still not found, try to read from Macros.h
+    if(NOT GTSAM_EIGEN_VERSION)
+        # Try to find Macros.h using find_file (more robust than checking paths)
+        find_file(EIGEN_MACROS_H
+            NAMES Eigen/src/Core/util/Macros.h
+            PATHS
+                ${GTSAM_EIGEN_INCLUDE_FOR_BUILD}
+                ${EIGEN3_INCLUDE_DIR}
+                /opt/homebrew/include/eigen3
+                /usr/local/include/eigen3
+                /usr/include/eigen3
+            NO_DEFAULT_PATH
+        )
+        
+        # If not found with NO_DEFAULT_PATH, try with default paths
+        if(NOT EIGEN_MACROS_H)
+            find_file(EIGEN_MACROS_H
+                NAMES Eigen/src/Core/util/Macros.h
+                PATH_SUFFIXES eigen3
+            )
+        endif()
+        
+        # Also try alternative paths
+        if(NOT EIGEN_MACROS_H)
+            set(EIGEN_VER_H_CANDIDATES
+                "${GTSAM_EIGEN_INCLUDE_FOR_BUILD}/Eigen/src/Core/util/Macros.h"
+                "${GTSAM_EIGEN_INCLUDE_FOR_BUILD}/eigen3/Eigen/src/Core/util/Macros.h"
+            )
+            if(DEFINED EIGEN3_INCLUDE_DIR AND NOT EIGEN3_INCLUDE_DIR STREQUAL "")
+                list(APPEND EIGEN_VER_H_CANDIDATES
+                    "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h"
+                    "${EIGEN3_INCLUDE_DIR}/eigen3/Eigen/src/Core/util/Macros.h"
+                )
+            endif()
+            foreach(CANDIDATE ${EIGEN_VER_H_CANDIDATES})
+                if(EXISTS "${CANDIDATE}")
+                    set(EIGEN_MACROS_H "${CANDIDATE}")
+                    break()
+                endif()
+            endforeach()
+        endif()
+        
+        if(EIGEN_MACROS_H)
+            file(READ "${EIGEN_MACROS_H}" STR_EIGEN_VERSION)
+
+            # Extract the Eigen version from the Macros.h file, lines "#define EIGEN_WORLD_VERSION  XX", etc...
+
+            string(REGEX MATCH "EIGEN_WORLD_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_WORLD "${STR_EIGEN_VERSION}")
+            string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_WORLD "${GTSAM_EIGEN_VERSION_WORLD}")
+
+            string(REGEX MATCH "EIGEN_MAJOR_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_MAJOR "${STR_EIGEN_VERSION}")
+            string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_MAJOR "${GTSAM_EIGEN_VERSION_MAJOR}")
+
+            string(REGEX MATCH "EIGEN_MINOR_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_MINOR "${STR_EIGEN_VERSION}")
+            string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_MINOR "${GTSAM_EIGEN_VERSION_MINOR}")
+
+            if(GTSAM_EIGEN_VERSION_WORLD AND GTSAM_EIGEN_VERSION_MAJOR AND GTSAM_EIGEN_VERSION_MINOR)
+                set(GTSAM_EIGEN_VERSION "${GTSAM_EIGEN_VERSION_WORLD}.${GTSAM_EIGEN_VERSION_MAJOR}.${GTSAM_EIGEN_VERSION_MINOR}")
+            endif()
+        endif()
+    endif()
+else()
+    # Use bundled Eigen - read from Macros.h
+    set(EIGEN_VER_H "${GTSAM_EIGEN_INCLUDE_FOR_BUILD}/Eigen/src/Core/util/Macros.h")
+    if(EXISTS ${EIGEN_VER_H})
+        file(READ "${EIGEN_VER_H}" STR_EIGEN_VERSION)
 
-    # Extract the Eigen version from the Macros.h file, lines "#define EIGEN_WORLD_VERSION  XX", etc...
+        # Extract the Eigen version from the Macros.h file, lines "#define EIGEN_WORLD_VERSION  XX", etc...
 
-    string(REGEX MATCH "EIGEN_WORLD_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_WORLD "${STR_EIGEN_VERSION}")
-    string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_WORLD "${GTSAM_EIGEN_VERSION_WORLD}")
+        string(REGEX MATCH "EIGEN_WORLD_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_WORLD "${STR_EIGEN_VERSION}")
+        string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_WORLD "${GTSAM_EIGEN_VERSION_WORLD}")
 
-    string(REGEX MATCH "EIGEN_MAJOR_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_MAJOR "${STR_EIGEN_VERSION}")
-    string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_MAJOR "${GTSAM_EIGEN_VERSION_MAJOR}")
+        string(REGEX MATCH "EIGEN_MAJOR_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_MAJOR "${STR_EIGEN_VERSION}")
+        string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_MAJOR "${GTSAM_EIGEN_VERSION_MAJOR}")
 
-    string(REGEX MATCH "EIGEN_MINOR_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_MINOR "${STR_EIGEN_VERSION}")
-    string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_MINOR "${GTSAM_EIGEN_VERSION_MINOR}")
+        string(REGEX MATCH "EIGEN_MINOR_VERSION[ ]+[0-9]+" GTSAM_EIGEN_VERSION_MINOR "${STR_EIGEN_VERSION}")
+        string(REGEX MATCH "[0-9]+" GTSAM_EIGEN_VERSION_MINOR "${GTSAM_EIGEN_VERSION_MINOR}")
 
-    set(GTSAM_EIGEN_VERSION "${GTSAM_EIGEN_VERSION_WORLD}.${GTSAM_EIGEN_VERSION_MAJOR}.${GTSAM_EIGEN_VERSION_MINOR}")
+        if(GTSAM_EIGEN_VERSION_WORLD AND GTSAM_EIGEN_VERSION_MAJOR AND GTSAM_EIGEN_VERSION_MINOR)
+            set(GTSAM_EIGEN_VERSION "${GTSAM_EIGEN_VERSION_WORLD}.${GTSAM_EIGEN_VERSION_MAJOR}.${GTSAM_EIGEN_VERSION_MINOR}")
+        endif()
+    endif()
+endif()
 
+if(GTSAM_EIGEN_VERSION)
     message(STATUS "Found Eigen version: ${GTSAM_EIGEN_VERSION}")
 else()
-    message(WARNING "Cannot determine Eigen version, missing file: `${EIGEN_VER_H}`")
-endif ()
+    message(WARNING "Cannot determine Eigen version")
+endif()
 
 if (MSVC)
     if (BUILD_SHARED_LIBS)
diff --git a/gtsam/3rdparty/Spectra/MatOp/internal/ArnoldiOp.h b/gtsam/3rdparty/Spectra/MatOp/internal/ArnoldiOp.h
index 68654aafd..cbcb77c89 100644
--- a/gtsam/3rdparty/Spectra/MatOp/internal/ArnoldiOp.h
+++ b/gtsam/3rdparty/Spectra/MatOp/internal/ArnoldiOp.h
@@ -105,7 +105,7 @@ private:
     OpType& m_op;
 
 public:
-    ArnoldiOp<Scalar, OpType, IdentityBOp>(OpType* op, IdentityBOp* /*Bop*/) :
+    ArnoldiOp(OpType* op, IdentityBOp* /*Bop*/) :
         m_op(*op)
     {}
 
diff --git a/gtsam/base/Matrix.h b/gtsam/base/Matrix.h
index cfedf6d8c..c2234f350 100644
--- a/gtsam/base/Matrix.h
+++ b/gtsam/base/Matrix.h
@@ -42,19 +42,22 @@ typedef Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> M
 
 // Create handy typedefs and constants for square-size matrices
 // MatrixMN, MatrixN = MatrixNN, I_NxN, and Z_NxN, for M,N=1..9
-#define GTSAM_MAKE_MATRIX_DEFS(N)   \
-using Matrix##N = Eigen::Matrix<double, N, N>;  \
-using Matrix1##N = Eigen::Matrix<double, 1, N>;  \
-using Matrix2##N = Eigen::Matrix<double, 2, N>;  \
-using Matrix3##N = Eigen::Matrix<double, 3, N>;  \
-using Matrix4##N = Eigen::Matrix<double, 4, N>;  \
-using Matrix5##N = Eigen::Matrix<double, 5, N>;  \
-using Matrix6##N = Eigen::Matrix<double, 6, N>;  \
-using Matrix7##N = Eigen::Matrix<double, 7, N>;  \
-using Matrix8##N = Eigen::Matrix<double, 8, N>;  \
-using Matrix9##N = Eigen::Matrix<double, 9, N>;  \
-static const Eigen::MatrixBase<Matrix##N>::IdentityReturnType I_##N##x##N = Matrix##N::Identity(); \
-static const Eigen::MatrixBase<Matrix##N>::ConstantReturnType Z_##N##x##N = Matrix##N::Zero();
+// NOTE: We use the concrete Eigen matrix types here instead of
+// MatrixBase<...>::IdentityReturnType / ConstantReturnType to avoid
+// incompatibilities with newer Eigen versions (e.g., Eigen 3.4+).
+#define GTSAM_MAKE_MATRIX_DEFS(N)                    \
+using Matrix##N = Eigen::Matrix<double, N, N>;       \
+using Matrix1##N = Eigen::Matrix<double, 1, N>;      \
+using Matrix2##N = Eigen::Matrix<double, 2, N>;      \
+using Matrix3##N = Eigen::Matrix<double, 3, N>;      \
+using Matrix4##N = Eigen::Matrix<double, 4, N>;      \
+using Matrix5##N = Eigen::Matrix<double, 5, N>;      \
+using Matrix6##N = Eigen::Matrix<double, 6, N>;      \
+using Matrix7##N = Eigen::Matrix<double, 7, N>;      \
+using Matrix8##N = Eigen::Matrix<double, 8, N>;      \
+using Matrix9##N = Eigen::Matrix<double, 9, N>;      \
+static const Matrix##N I_##N##x##N = Matrix##N::Identity(); \
+static const Matrix##N Z_##N##x##N = Matrix##N::Zero();
 
 GTSAM_MAKE_MATRIX_DEFS(1)
 GTSAM_MAKE_MATRIX_DEFS(2)
diff --git a/gtsam/base/Vector.h b/gtsam/base/Vector.h
index f7923ff88..6cacb2e2f 100644
--- a/gtsam/base/Vector.h
+++ b/gtsam/base/Vector.h
@@ -29,6 +29,7 @@
 #include <Eigen/Core>
 #include <iosfwd>
 #include <list>
+#include <cassert>
 
 namespace gtsam {
 
@@ -42,14 +43,19 @@ typedef Eigen::Matrix<double, 1, 1> Vector1;
 typedef Eigen::Vector2d Vector2;
 typedef Eigen::Vector3d Vector3;
 
-static const Eigen::MatrixBase<Vector2>::ConstantReturnType Z_2x1 = Vector2::Zero();
-static const Eigen::MatrixBase<Vector3>::ConstantReturnType Z_3x1 = Vector3::Zero();
+// Zero column vectors of various sizes.
+// NOTE: We use the concrete Eigen vector types here instead of
+// MatrixBase<...>::ConstantReturnType to avoid incompatibilities with
+// newer Eigen versions (e.g., Eigen 3.4+) where Zero()/Constant() no
+// longer convert cleanly to ConstantReturnType.
+static const Vector2 Z_2x1 = Vector2::Zero();
+static const Vector3 Z_3x1 = Vector3::Zero();
 
 // Create handy typedefs and constants for vectors with N>3
-// VectorN and Z_Nx1, for N=1..9
-#define GTSAM_MAKE_VECTOR_DEFS(N)                \
-  using Vector##N = Eigen::Matrix<double, N, 1>; \
-  static const Eigen::MatrixBase<Vector##N>::ConstantReturnType Z_##N##x1 = Vector##N::Zero();
+// VectorN and Z_Nx1, for N>3
+#define GTSAM_MAKE_VECTOR_DEFS(N)                 \
+  using Vector##N = Eigen::Matrix<double, N, 1>;  \
+  static const Vector##N Z_##N##x1 = Vector##N::Zero();
 
 GTSAM_MAKE_VECTOR_DEFS(4)
 GTSAM_MAKE_VECTOR_DEFS(5)
diff --git a/gtsam/linear/iterative.h b/gtsam/linear/iterative.h
index 22f65b8de..8250cc1ff 100644
--- a/gtsam/linear/iterative.h
+++ b/gtsam/linear/iterative.h
@@ -71,7 +71,8 @@ namespace gtsam {
 
     /** gradient of objective function 0.5*|Ax-b_|^2 at x = A_'*(Ax-b_) */
     Vector gradient(const Vector& x) const {
-      return A() ^ (A() * x - b());
+      const Vector residual = A() * x - b();
+      return A() ^ residual;
     }
 
     /** Apply operator A */
diff --git a/python/gtsam/tests/test_DiscreteBayesNet.py b/python/gtsam/tests/test_DiscreteBayesNet.py
index d597effa8..e86795795 100644
--- a/python/gtsam/tests/test_DiscreteBayesNet.py
+++ b/python/gtsam/tests/test_DiscreteBayesNet.py
@@ -110,7 +110,7 @@ class TestDiscreteBayesNet(GtsamTestCase):
         # now sample from it
         chordal2 = fg.eliminateSequential(ordering)
         actualSample = chordal2.sample()
-        self.assertEqual(len(actualSample), 8)
+        self.assertEqual(len(list(actualSample.keys())), 8)
 
     def test_fragment(self):
         """Test evaluate/sampling/optimizing for Asia fragment."""
@@ -128,7 +128,7 @@ class TestDiscreteBayesNet(GtsamTestCase):
 
         # Now sample from fragment:
         values = fragment.sample(given)
-        self.assertEqual(len(values), 5)
+        self.assertEqual(len(list(values.keys())), 5)
 
         for i in [0, 1, 2]:
             self.assertAlmostEqual(fragment.at(i).logProbability(values),
